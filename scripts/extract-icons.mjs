#!/usr/bin/env node
/**
 * Script to extract only the icons used in the project
 * and generate a minimal JSON file for bundling.
 *
 * Run: node scripts/extract-icons.mjs
 */
import { readFileSync, writeFileSync } from 'fs';
import { execSync } from 'child_process';

// Find all icons used in the source code
const grepOutput = execSync(
    "grep -rho 'icon=\"[^\"]*\"' src/ | sed 's/icon=\"//;s/\"$//' | sort -u",
    { encoding: 'utf-8', cwd: process.cwd() }
);

const usedIcons = grepOutput.trim().split('\n').filter(Boolean);
console.log(`Found ${usedIcons.length} unique icons in source code`);

// Group icons by prefix
const iconsByPrefix = {};
for (const icon of usedIcons) {
    const [prefix, name] = icon.split(':');
    if (!iconsByPrefix[prefix]) {
        iconsByPrefix[prefix] = [];
    }
    iconsByPrefix[prefix].push(name);
}

console.log('Icons by prefix:', Object.entries(iconsByPrefix).map(([k, v]) => `${k}: ${v.length}`).join(', '));

// Also add icons that might be dynamically generated (linear/bold variants)
const additionalIcons = {
    solar: [
        'home-2-bold', 'user-bold', 'magnifer-bold', 'bell-bold',
        'heart-linear', 'bookmark-linear', 'cloud-check-linear', 'cloud-upload-linear',
    ],
    mdi: ['github'],
};

for (const [prefix, icons] of Object.entries(additionalIcons)) {
    if (!iconsByPrefix[prefix]) {
        iconsByPrefix[prefix] = [];
    }
    for (const icon of icons) {
        if (!iconsByPrefix[prefix].includes(icon)) {
            iconsByPrefix[prefix].push(icon);
        }
    }
}

// Extract icon data from JSON files
const extractedIcons = { icons: {} };
let totalIcons = 0;

for (const [prefix, iconNames] of Object.entries(iconsByPrefix)) {
    try {
        const jsonPath = `node_modules/@iconify-json/${prefix}/icons.json`;
        const collection = JSON.parse(readFileSync(jsonPath, 'utf-8'));

        for (const name of iconNames) {
            const iconData = collection.icons[name];
            if (iconData) {
                extractedIcons.icons[`${prefix}:${name}`] = {
                    body: iconData.body,
                    width: iconData.width || collection.width || 24,
                    height: iconData.height || collection.height || 24,
                };
                totalIcons++;
            } else {
                console.warn(`Icon not found: ${prefix}:${name}`);
            }
        }
    } catch (err) {
        console.error(`Failed to load ${prefix} icons:`, err.message);
    }
}

console.log(`Extracted ${totalIcons} icons`);

// Write output
const output = `// Auto-generated - DO NOT EDIT
// Generated by: node scripts/extract-icons.mjs
// Icons: ${totalIcons}

export const iconData = ${JSON.stringify(extractedIcons, null, 2)};
`;

writeFileSync('src/lib/icons-data.ts', output);
console.log('Written to src/lib/icons-data.ts');

// Calculate size
const sizeKB = (Buffer.byteLength(output, 'utf-8') / 1024).toFixed(1);
console.log(`File size: ${sizeKB} KB (will be smaller after gzip)`);
